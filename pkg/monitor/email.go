package monitor

import (
	"crypto/tls"
	"fmt"
	"net/smtp"
	"time"
)

// EmailConfig holds SMTP email configuration
type EmailConfig struct {
	Enabled   bool          `yaml:"enabled"`
	SMTPHost  string        `yaml:"smtp_host"`
	SMTPPort  int           `yaml:"smtp_port"`
	Username  string        `yaml:"username"`
	Password  string        `yaml:"password"`
	FromEmail string        `yaml:"from_email"`
	FromName  string        `yaml:"from_name"`
	TLS       bool          `yaml:"tls"`
	Interval  time.Duration `yaml:"interval"`
}

// sendEmailAlert sends an alert via SMTP email
func (m *Monitor) sendEmailAlert(queryName string, rule AlertRule) error {

	// Check if enough time has passed since last alert
	if !m.alertTracker.CanSendAlert(queryName, "email", m.config.Alerts.Email.Interval) {
		m.logger.Printf("Email alert for query %s skipped due to interval limit", queryName)
		return fmt.Errorf("email alert for query %s skipped due to interval limit", queryName)
	}

	// Prepare email content
	subject := fmt.Sprintf("[%s] Database Alert: %s", m.config.Instance, queryName)

	// Create HTML email body
	htmlBody := fmt.Sprintf(`
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .header { background-color: #f4f4f4; padding: 10px; border-left: 4px solid #d32f2f; }
        .content { padding: 20px; }
        .alert-info { background-color: #fff3cd; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .critical { border-left: 4px solid #d32f2f; }
        .performance { border-left: 4px solid #ff9800; }
        .storage { border-left: 4px solid #ffeb3b; }
        .maintenance { border-left: 4px solid #2196f3; }
        .security { border-left: 4px solid #f44336; }
        table { border-collapse: collapse; width: 100%%; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <div class="header">
        <h2>ðŸš¨ Database Alert</h2>
    </div>
    <div class="content">
        <div class="alert-info %s">
            <h3>%s</h3>
            <p><strong>Message:</strong> %s</p>
        </div>
        
        <table>
            <tr><th>Instance</th><td>%s</td></tr>
            <tr><th>Query</th><td>%s</td></tr>
            <tr><th>Category</th><td>%s</td></tr>
            <tr><th>Timestamp</th><td>%s</td></tr>
            <tr><th>Recipient</th><td>%s</td></tr>
        </table>
        
        <p><em>This alert was automatically generated by PostgreSQL Database Monitor.</em></p>
    </div>
</body>
</html>`,
		rule.Category,
		rule.Message,
		rule.Message,
		m.config.Instance,
		queryName,
		rule.Category,
		time.Now().Format("2006-01-02 15:04:05 MST"),
		rule.To,
	)

	// Create plain text version
	textBody := fmt.Sprintf(`Database Alert: %s

Instance: %s
Query: %s  
Category: %s
Message: %s
Timestamp: %s
Recipient: %s

This alert was automatically generated by PostgreSQL Database Monitor.`,
		queryName,
		m.config.Instance,
		queryName,
		rule.Category,
		rule.Message,
		time.Now().Format("2006-01-02 15:04:05 MST"),
		rule.To,
	)

	// Send email
	err := m.sendEmail(rule.To, subject, textBody, htmlBody)
	if err != nil {
		m.logger.Printf("Email alert failed for query %s: %v", queryName, err)
		return fmt.Errorf("failed to send email alert for query %s: %w", queryName, err)
	}

	m.logger.Printf("Email alert sent successfully for query: %s", queryName)
	m.alertTracker.RecordAlert(queryName, "email")

	return nil
}

// sendEmail sends an email using SMTP
func (m *Monitor) sendEmail(to, subject, textBody, htmlBody string) error {
	config := m.config.Alerts.Email

	// Create authentication
	auth := smtp.PlainAuth("", config.Username, config.Password, config.SMTPHost)

	// Prepare headers
	from := config.FromEmail
	if config.FromName != "" {
		from = fmt.Sprintf("%s <%s>", config.FromName, config.FromEmail)
	}

	// Create multipart message
	boundary := "boundary-postgres-stat-alert-" + fmt.Sprintf("%d", time.Now().Unix())

	headers := fmt.Sprintf("From: %s\r\nTo: %s\r\nSubject: %s\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative; boundary=%s\r\n\r\n",
		from, to, subject, boundary)

	textPart := fmt.Sprintf("--%s\r\nContent-Type: text/plain; charset=UTF-8\r\n\r\n%s\r\n\r\n", boundary, textBody)
	htmlPart := fmt.Sprintf("--%s\r\nContent-Type: text/html; charset=UTF-8\r\n\r\n%s\r\n\r\n", boundary, htmlBody)
	ending := fmt.Sprintf("--%s--\r\n", boundary)

	message := headers + textPart + htmlPart + ending

	// Connect and send
	addr := fmt.Sprintf("%s:%d", config.SMTPHost, config.SMTPPort)

	if config.TLS {
		// Use TLS connection
		tlsConfig := &tls.Config{
			ServerName: config.SMTPHost,
		}

		conn, err := tls.Dial("tcp", addr, tlsConfig)
		if err != nil {
			return fmt.Errorf("failed to connect with TLS: %w", err)
		}
		defer conn.Close()

		client, err := smtp.NewClient(conn, config.SMTPHost)
		if err != nil {
			return fmt.Errorf("failed to create SMTP client: %w", err)
		}
		defer client.Quit()

		if err = client.Auth(auth); err != nil {
			return fmt.Errorf("SMTP authentication failed: %w", err)
		}

		if err = client.Mail(config.FromEmail); err != nil {
			return fmt.Errorf("failed to set sender: %w", err)
		}

		if err = client.Rcpt(to); err != nil {
			return fmt.Errorf("failed to set recipient: %w", err)
		}

		w, err := client.Data()
		if err != nil {
			return fmt.Errorf("failed to get data writer: %w", err)
		}

		_, err = w.Write([]byte(message))
		if err != nil {
			return fmt.Errorf("failed to write message: %w", err)
		}

		err = w.Close()
		if err != nil {
			return fmt.Errorf("failed to close data writer: %w", err)
		}

	} else {
		// Use plain SMTP
		err := smtp.SendMail(addr, auth, config.FromEmail, []string{to}, []byte(message))
		if err != nil {
			return fmt.Errorf("failed to send email: %w", err)
		}
	}

	return nil
}
